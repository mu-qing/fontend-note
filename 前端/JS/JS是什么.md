### 前言

学习一门语言的语法并且能写出一些功能是很简单的，但要真正的掌握一门语言，不能只停留在语法层，重点是而是要去探究这个语言为何诞生，用于何处和别的语言在本质上有何不同，又为何这样设计，在繁杂的语法中找出本质的东西。

### JavaScript的诞生？

   1994年，网景公司发布了历史上第一个比较成熟的网络浏览器，轰动一时。但是，这时浏览器只能用来看东西，无法与用户交互的。比如用户填写了用户名，浏览器无法判断用户有没有填，每一次填写都必须让服务端判断，如果错了，就要重新填，这样非常的耗费时间和服务器的资源。
    
   因此急需一个语言，可以让浏览器和用户互动，当时，Java语言非常的火爆，但是Java语言嵌入脚本会使得网页很复杂，因此放弃了，后来网景公司决定发明一种新的语言，这个语言要和Java语法相似，但是比Java简单，让非专业的网页作者也能很快上手。

   34岁的系统程序员Brendan Eich负责设计这个脚本语言，但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。他的设计思路是这样的：

```

```

　　（1）借鉴C语言的基本语法；

　　（2）借鉴Java语言的数据类型和内存管理；

　　（3）借鉴Scheme语言，将函数提升到"第一等公民"（first class）的地位；

　　（4）借鉴Self语言，使用基于原型（prototype）的继承机制。

```

```

 所以，Javascript语言实际上是两种语言风格的混合产物----（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。

JavaScript推出后在浏览器上大获成功，后面不同的公司就推出了新的实现，这使得JavaScript使用收到阻碍。

1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262，JavaScript成为了ECMAScript最著名的实现之一。

因此，ECMAScript是一个语言标准，JavaScript可以认为是ECMAScript的一个实现。

一般来说，完整的JavaScript包括以下几个部分：

- ECMAScript，描述了该语言的语法和基本对象

- 文档对象模型（DOM），描述处理网页内容的方法和接口

- 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口

  

### JavaScript是什么？

> **维基百科**：JavaScript，是一种高级的，**解释执行**的脚本语言[5]。JavaScript是一门**基于原型、函数先行**的语言[6]，是一门**多范式**的语言，它支持**面向对象编程，命令式编程，以及函数式编程**。它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的**宿主环境**提供支持。它已经由ECMA（欧洲计算机制造商协会）通过**ECMAScript实现语言的标准化**[5]。

从维基百科的解释中，我们可以得出几个信息： 

- 是一种高级的，**解释执行**的脚本语言
- 有自己的语法特性：基于原型、函数先行等，语法上遵循ECMAScript标准
- 宿主环境

下面我们从这些关键词来解释这门语言。

#### 高级

我们常常听说的语言有三种：机器语言，汇编语言，高级语言。

- 机器语言：计算机是采用二进制进行计算的，这种二进制语言叫做机器语言
- 汇编语言：为了写代码方便，汇编语言诞生了，也叫字节码，中间码等，比二进制稍微高级的标识语言  比如ADD a 代表 010101  一般一个标识语句 对应一个机器语言
- 高级语言：为了写代码更方便，高级语言诞生了，一行可以被转换成多行机器语言。JavaScript就是一种高级语言。

所有的高级语言需要被转换成二进制语言才能被执行。而转换二进制需要特定的工具。这个工具一般是编译器或者解释型



#### 解释执行

高级语言执行前，都需要被转换成二进制。但对于这个转换过程，有很多种不同的方式。所以才诞生了解释执行，编译型等。其实本质都是一样的。

- 解释执行： 高级代码直接放在运行环境中，由解释器解释成二进制，每一次执行都会重新解释，所以运行的速度相对慢。

- 编译执行：高级代码先编译成二进制，再放到运行环境直接运行。一次解释，直接运行，所以运行很快。

- 其他： 高级代码先编译成汇编语言，然后放到运行环境，一边编译成二进制，一边运行，属于上面二则的折中。

  

  notes： 汇编语言转成二进制 会比高级语言转成二进制的速度要快。

JavaScript由JavaScript引擎来执行，虽说JavaScript是解释执行，但是引擎有做一些优化，这个就要具体去学习了，这里先不讨论。



#### 脚本语言

其实“脚本语言”与“非脚本语言”并没有语义上，或者执行方式上的区别。它们的区别只在于它们设计的初衷：脚本语言往往是为某一特定运行时环境编写的程序、支持自动执行任务的编程语言。比如js一开始设计主要是在浏览器环境运行的。

#### 宿主环境

JavaScript本身只是一门语言，语言要想运行，就要提供执行语言的环境，JavaScript的运行环境主要有浏览器和Node，浏览器中提供了JS引擎来解析代码，Node提供了V8引擎来解析JavaScript代码

##### 流行的JavaScript引擎：

- V8：开源，Google开发，C++，Chrome浏览器 Rhino：开源，Mozilla开发，Java

- SpiderMonkey：第一个JavaScript引擎，网景浏览器（之前）和Firefox（现在）

- JavaScriptCore：开源，苹果Safari浏览器 - Chakra（JSscript9）：Internet Explorer浏览器

- Chakra（JavaScript）：Microsoft Edge浏览器

  

#### 语法特性

这个点比较多，以后的文章中具体介绍



#### 程序执行时内存是什么时候分配的？

编译或者解释时是不分配内存的。此时只是根据声明时的类型进行占位，所以声明是给编译器看的，聪明的编译器能根据声明帮你识别错误。当被编译成机器码交给CPU的时候，CPU会把程序加载到内存，开始一行行执行的时候，才分配内存。



#### js如何实现的内存动态分配

javascript中的变量分为两种，原始值和引用值。

原始值和引用值存储在内存中的位置分别为栈和堆。原始值是存储在栈中的简单数据段，他们的值直接存储在变量访问的位置。引用值是存储在堆中的对象。

#### 动态类型语言 与 静态类型语言

##### 动态：

运行期间才做数据类型检查的语言，永远不用给任何变量指定数据类型。该语言会在第一次赋值给变量时，在内部将数据类型记录下来。

**优点**：方便阅读，不需要写非常多的类型相关的代码；

**缺点**：不方便调试，命名不规范时会造成读不懂，不利于理解等

##### 静态 

编译期间做检查数据类型的语言，即写程序时要声明所有变量的数据类型，是固定的。使用数据之前，必须先声明数据类型（int ,float,double等）。相当于使用之前，首先要为它们分配好内存空间。

**优点**：结构非常规范，便于调试，方便类型安全

**缺点**：为此需要写更多类型相关代码，不便于阅读、不清晰明了

#### Js的内存管理

JavaScript的运行环境？

#### 内存泄漏？

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
内存溢出：调用栈溢出，栈内存不足

基本的数据结构

语言特性

javascript的原型/闭包/函数等等

内存回收？

二、垃圾回收机制
垃圾回收机制怎么知道，哪些内存不再需要呢？

最常使用的方法叫做"引用计数"（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

![](https://user-gold-cdn.xitu.io/2019/3/7/16956f5b5612dc79?w=273&h=268&f=png&s=7180)

上图中，左下角的两个值，没有任何引用，所以可以释放。

如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

```
const arr = [1, 2, 3, 4];
console.log('hello world');
```

上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。

如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。

```
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;
```

上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。

因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。

#### 内存泄漏的识别方法

怎样可以观察到内存泄漏呢？

经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。

Chrome 浏览器查看内存占用，按照以下步骤操作。

打开开发者工具，选择perfermance勾选 Memory
点击左上角的录制按钮。
在页面上进行各种操作，模拟用户的使用情况。
一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。

如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。

进程： 处理一个程序的最小单元，也就是完整的步骤

比如一个计算程序程序执行过程：
运行程序--程序加载到内存--CPU从内存取程序--ALU计算--计算完成放到寄存器。这样一个完整的流程叫进程。 每个程序基本都是这样执行的。
而其中的一个步骤：比如取指令，这就叫做一个线程，是进程的最小单位。

浏览器是多线程的：GUI渲染  定时器  http请求的线程 js引擎线程。

CPU实现了多进程：并发执行指令





# JS 思考题

之前我们通过了七个章节来学习关于 JS 这部分的内容，那么接下来，会以几道思考题的方式来确保大家理解这部分的内容。

这种方式不仅能加深你对知识点的理解，同时也能帮助你串联起多个碎片知识点。一旦你拥有将多个碎片知识点串联起来的能力，在面试中就不会经常出现一问一答的情况。如果面试官的每个问题你都能引申出一些相关联的知识点，那么面试官一定会提高对你的评价。

```!
思考题一：JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？
```

首先这几道题目想必很多人都能够很好的答出来，接下来就给大家一点思路讲出与众不同的东西。

**思路引导：**

1. 对于原始类型来说，你可以指出 `null` 和 `number` 存在的一些问题。对于对象类型来说，你可以从垃圾回收的角度去切入，也可以说一下对象类型存在深浅拷贝的问题。
2. 对于判断类型来说，你可以去对比一下 `typeof` 和 `instanceof` 之间的区别，也可以指出 `instanceof` 判断类型也不是完全准确的。

以上就是这道题目的回答思路，当然不是说让大家完全按照这个思路去答题，而是存在一个意识，当回答面试题的时候，尽量去引申出这个知识点的某些坑或者与这个知识点相关联的东西。

```!
思考题二：你理解的原型是什么？
```

**思路引导：**

起码说出原型小节中的总结内容，然后还可以指出一些小点，比如并不是所有函数都有 `prototype` 属性，然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 `class` 实现继承。

```!
思考题三：bind、call 和 apply 各自有什么区别？
```

**思路引导：**

首先肯定是说出三者的不同，如果自己实现过其中的函数，可以尝试说出自己的思路。然后可以聊一聊 `this` 的内容，有几种规则判断 `this` 到底是什么，`this` 规则会涉及到 `new`，那么最后可以说下自己对于 `new` 的理解。

```!
思考题四：ES6 中有使用过什么？
```

**思路引导：**

这边可说的实在太多，你可以列举 1 - 2 个点。比如说说 `class`，那么 `class` 又可以拉回到原型的问题；可以说说 `promise`，那么线就被拉到了异步的内容；可以说说 `proxy`，那么如果你使用过 Vue 这个框架，就可以谈谈响应式原理的内容；同样也可以说说 `let` 这些声明变量的语法，那么就可以谈及与 `var` 的不同，说到提升这块的内容。

```!
思考题五：JS 是如何运行的？
```

**思路引导：**

这其实是很大的一块内容。你可以先说 JS 是单线程运行的，这里就可以说说你理解的线程和进程的区别。然后讲到执行栈，接下来的内容就是涉及 Eventloop 了，微任务和宏任务的区别，哪些是微任务，哪些又是宏任务，还可以谈及浏览器和 Node 中的 Eventloop 的不同，最后还可以聊一聊 JS 中的垃圾回收。

## 小结

虽然思考题不多，但是其实每一道思考题背后都可以引申出很多内容，大家接下去在学习的过程中也应该始终有一个意识，你学习的这块内容到底和你现在脑海里的哪一个知识点有关联。同时也欢迎大家总结这些思考题，并且把总结的内容链接放在评论中，我会挑选出不错的文章单独放入一章节给大家参考。