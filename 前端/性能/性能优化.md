# 性能优化琐碎事

## 图片优化

### 图片压缩

图片分为矢量图和位图

**矢量图**：通过组成图形的一些基本元素，如点、线、面，边框，填充色等信息通过计算的方式来显示图形的。

文件相对较小，并且放大缩小不会失真。缺点则是这些完美的几何图形很难表现自然度高的写实图像。

**位图**：通过记录图像中每一个点的颜色、深度、透明度等信息来存储和显示图像。

位图的优点是利于显示色彩层次丰富的写实图像。缺点则是文件大小较大，放大和缩小图像会失真。

**无损压缩**：对于重复较多的颜色值，只储蓄一个，以及出现的次数。（**PNG**）

**有损压缩**：去掉容易被人忽略的颜色。GIF（8位） and PNG

**PNG**：无损压缩，颜色简单对比强烈

**JPG**：有损压缩，适合层次丰富颜色较多，PNG8：8位颜色值   PNG24： 24位颜色值

SVG：大小不大，可以在HTML标记内使用SVG代码并保存HTTP请求，SVG代码适合使用CSS进行自定义

您可以使用CSS和JavaScript为SVG图像（包括其各个部分）制作动画，这非常酷。

尽量避免过于复杂的SVG图像供Web使用。最后，对于摄影图像，SVG不适合，你最好坚持使用JPG格式或webP。

### 图片加载优化

1. 尽量不用图片，用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 图片 使用图标字体 
5. 选择正确的图片格式：
   - 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   - 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   - 照片使用 JPEG

#### base64

**原理**：base64是一种用于传输8Bit字节码编码方式，基于64个可打印字符来标识二进制数据， Base64编码指的是从二进制转到字符的过程

**产生原因：**因为网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就不能通过邮件传送，这样就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了，而Base64就是一种基于64个可见字符来表示二进制数据的表示方法，把不可见字符用可见字符来表示。

**扩展：不可见字符其实并不是不显示，只是这些字符在屏幕上显示不出来，比如：换行符、回车、退格......字符。**

**优点**: 可以将二进制数据转化为可打印字符，方便传输数据，对数据进行简单的加密，肉眼安全。

**缺点**：内容编码后体积变大，CPU编码和解码需要额外工作量。

## DNS 预解析

访问网页的时候，DNS需要把网页的每个域名都通过DNS解析出IP地址。为了优化体验，我们可以提前解析DNS。

```html
<link rel="dns-prefetch" href="//yuchengkai.cn">
```

## 节流 

**一定时间内只执行一次。**

场景：滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。

理解了节流的用途，我们就来实现下这个函数

```js
// func是用户传入需要节流的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
  // 上一次执行该函数的时间
  let lastTime = 0
  return function(...args) {
    // 当前时间
    let now = +new Date()
    // 将当前时间和上一次执行函数时间对比
    // 如果差值大于设置的等待时间就执行函数
    if (now - lastTime > wait) {
      lastTime = now
      func.apply(this, args)
    }
  }
}

setInterval(
  throttle(() => {
    console.log(1)
  }, 500),
  1
)
```

## 防抖

**任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**

场景：有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求

解决：当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求， 首先需要设置一个时间，假如1秒，如果点击了之后，1秒才会发请求，如果还没过1秒，用户又点击了一次，就会先取消掉上次的定时器，开一个新的定时器。这样最终只会发一个请求

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = null;
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}


关于...args，以下两种写法相同
function max() {
  var values = Array.prototype.slice.call(arguments, 0); 把arguments转成数组
}
max(1,2,3);


function max(...value) {}
max(1,2,3);
```

## 预加载

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。

预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载

```html
<link rel="preload" href="http://example.com">
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

## 预渲染

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com"> 
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。

## 懒执行

懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

## 懒加载

懒加载就是将不关键的资源延后加载。

懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 `src` 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 `src` 属性，这样图片就会去下载资源，实现了图片懒加载。

懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。

## CDN

CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。

因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

